---
title: MIT 6.S081 Operating system interface笔记
date: 2021-03-06 09:36:59
tags:
---
[xv6 book](https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf)  
## pipe
```c
int p[2];
char *argv[2];

argv[0] = "wc";
argv[1] = 0;

pipe(p);
if(fork() == 0) {
  close(0);
  dup(p[0]);
  close(p[0]);
  close(p[1]);
  exec("/bin/wc", argv);
} else {
  close(p[0]);
  write(p[1], "hello world\n", 12);
  close(p[1]);
}
```
这段代码用于演示pipe的用法，需要注意的是代码中dup的作用，首先需要明白的是新分配的文件描述符始终是当前进程中编号最小的未使用描述符，`close(0)`释放了文件描述符0，现在当前进程中最小的未使用描述符就是0，随后`dup(p[0])`就会将文件描述符0重定向至p[0]。  

## sh.c
sh.c是util lab中shell的代码实现。  
```shell
git clone git://g.csail.mit.edu/xv6-labs-2020  
cd xv6-labs-2020  
git checkout util
```
```c
case PIPE:
  pcmd = (struct pipecmd*)cmd;
  if(pipe(p) < 0)
    panic("pipe");
  if(fork1() == 0){
    close(1);
    dup(p[1]);
    close(p[0]);
    close(p[1]);
    runcmd(pcmd->left);
  }
  if(fork1() == 0){
    close(0);
    dup(p[0]);
    close(p[0]);
    close(p[1]);
    runcmd(pcmd->right);
  }
  close(p[0]);
  close(p[1]);
  wait(0);
  wait(0);
  break;
```
这里是将pipe `|` 左边程序的标准输出重定向到p[1]，右边程序的标准输入重定向到p[0]，从而实现pipe。有两点需要注意，
一是只有左边程序的标准输出可能被右边程序所有；二是要想成功使用pipe，右边程序必须得有从标准输入读取得操作。  
```shell
$ echo hello | wc
1 1 6 
$ echo hello | rm
Usage: rm files...
```
可以看到`|`右边接`wc`可以，但`rm`不行。原因就是wc有从标准输入中读，而rm没有。     
wc.c
```c
int
main(int argc, char *argv[])
{
  int fd, i;

  if(argc <= 1){
    wc(0, "");
    exit(0);
  }

  for(i = 1; i < argc; i++){
    if((fd = open(argv[i], 0)) < 0){
      printf("wc: cannot open %s\n", argv[i]);
      exit(1);
    }
    wc(fd, argv[i]);
    close(fd);
  }
  exit(0);
}
```

rm.c
```c
int
main(int argc, char *argv[])
{
  int i;

  if(argc < 2){
    fprintf(2, "Usage: rm files...\n");
    exit(1);
  }

  for(i = 1; i < argc; i++){
    if(unlink(argv[i]) < 0){
      fprintf(2, "rm: %s failed to delete\n", argv[i]);
      break;
    }
  }

  exit(0);
}
```